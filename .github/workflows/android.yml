name: Android Build + file_to_c Generation

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-android:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake git unzip wget gcc

    - name: Setup JDK 17
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3
      with:
        api-level: 34
        build-tools: 34.0.0
        ndk: 25.2.9519653
        cmake: 3.22.1

    # --- Create file_to_c inline ---
    - name: Cache file_to_c binary
      id: file-to-c-cache
      uses: actions/cache@v4
      with:
        path: /usr/local/bin/file_to_c
        key: file-to-c-${{ runner.os }}-v2

    - name: Build file_to_c utility
      if: steps.file-to-c-cache.outputs.cache-hit != 'true'
      run: |
        cat > /tmp/file_to_c.c << 'EOF'
        #include <stdio.h>
        #include <stdlib.h>
        #include <string.h>

        int main(int argc, char *argv[]) {
            if (argc != 5) {
                fprintf(stderr, "Usage: %s <input_file> <symbol_name> <output_c> <output_h>\n", argv[0]);
                return 1;
            }

            const char *input_file = argv[1];
            const char *symbol_name = argv[2];
            const char *output_c = argv[3];
            const char *output_h = argv[4];

            FILE *in = fopen(input_file, "rb");
            if (!in) {
                fprintf(stderr, "Error: Cannot open input file: %s\n", input_file);
                return 1;
            }

            // Get file size
            fseek(in, 0, SEEK_END);
            long size = ftell(in);
            fseek(in, 0, SEEK_SET);

            // Write header file
            FILE *h_out = fopen(output_h, "w");
            if (!h_out) {
                fprintf(stderr, "Error: Cannot create header file: %s\n", output_h);
                fclose(in);
                return 1;
            }
            fprintf(h_out, "#ifndef %s_H\n", symbol_name);
            fprintf(h_out, "#define %s_H\n\n", symbol_name);
            fprintf(h_out, "extern const unsigned char %s[];\n", symbol_name);
            fprintf(h_out, "extern const unsigned int %s_size;\n\n", symbol_name);
            fprintf(h_out, "#endif\n");
            fclose(h_out);

            // Write C file
            FILE *c_out = fopen(output_c, "w");
            if (!c_out) {
                fprintf(stderr, "Error: Cannot create C file: %s\n", output_c);
                fclose(in);
                return 1;
            }

            fprintf(c_out, "#include \"%s\"\n\n", strrchr(output_h, '/') ? strrchr(output_h, '/') + 1 : output_h);
            fprintf(c_out, "const unsigned char %s[] = {\n", symbol_name);

            unsigned char byte;
            long count = 0;
            while (fread(&byte, 1, 1, in) == 1) {
                if (count % 16 == 0) {
                    fprintf(c_out, "    ");
                }
                fprintf(c_out, "0x%02x", byte);
                count++;
                if (count < size) {
                    fprintf(c_out, ",");
                    if (count % 16 == 0) {
                        fprintf(c_out, "\n");
                    } else {
                        fprintf(c_out, " ");
                    }
                }
            }
            fprintf(c_out, "\n};\n\n");
            fprintf(c_out, "const unsigned int %s_size = %ld;\n", symbol_name, size);

            fclose(in);
            fclose(c_out);

            printf("Generated %s and %s for %s (%ld bytes)\n", output_c, output_h, input_file, size);
            return 0;
        }
        EOF

        echo "Compiling file_to_c..."
        gcc /tmp/file_to_c.c -o /tmp/file_to_c
        sudo cp /tmp/file_to_c /usr/local/bin/
        sudo chmod +x /usr/local/bin/file_to_c
        echo "file_to_c compiled successfully"

    - name: Verify file_to_c installation
      run: |
        echo "file_to_c location:"
        which file_to_c
        ls -la /usr/local/bin/file_to_c

    # --- Cache generated shader headers ---
    - name: Cache generated shader headers
      id: shader-cache
      uses: actions/cache@v4
      with:
        path: generated_shaders
        key: shader-cache-${{ runner.os }}-${{ hashFiles('shaders/*.hlsl') }}

    - name: Generate HLSL shader headers
      if: steps.shader-cache.outputs.cache-hit != 'true'
      run: |
        mkdir -p generated_shaders
        if ls shaders/*.hlsl 1> /dev/null 2>&1; then
          for vs in shaders/*.hlsl; do
              name=$(basename "$vs")
              out="$GITHUB_WORKSPACE/generated_shaders/$name"
              /usr/local/bin/file_to_c "$vs" "shader_$(basename $vs .hlsl)" "$out" "$out.h"
          done
        else
          echo "No HLSL shader files found in shaders/"
        fi

    # --- Cache generated mod headers ---
    - name: Cache generated mod headers
      id: mod-cache
      uses: actions/cache@v4
      with:
        path: android/app/src/main/cmods
        key: mod-cache-${{ runner.os }}-${{ hashFiles('mods/*.nrm') }}

    - name: Convert .nrm mods to C headers
      if: steps.mod-cache.outputs.cache-hit != 'true'
      run: |
        mkdir -p android/app/src/main/cmods
        if ls mods/*.nrm 1> /dev/null 2>&1; then
          for mod in mods/*.nrm; do
              modname=$(basename "$mod" .nrm)
              out="$GITHUB_WORKSPACE/android/app/src/main/cmods/$modname.c"
              /usr/local/bin/file_to_c "$mod" "$modname" "$out" "$out.h"
          done
        else
          echo "No .nrm mod files found in mods/"
        fi

    # --- Cache patches_bin.c ---
    - name: Cache patches_bin.c
      id: patches-cache
      uses: actions/cache@v4
      with:
        path: RecompiledPatches/patches_bin.c
        key: patches-cache-${{ runner.os }}-${{ hashFiles('patches/patches.bin') }}

    - name: Generate patches_bin.c
      if: steps.patches-cache.outputs.cache-hit != 'true'
      run: |
        mkdir -p RecompiledPatches
        if [ -f patches/patches.bin ]; then
            /usr/local/bin/file_to_c patches/patches.bin mm_patches_bin RecompiledPatches/patches_bin.c RecompiledPatches/patches_bin.h
        else
            echo "Warning: patches/patches.bin not found; skipping patches_bin.c"
        fi

    # --- Cache Gradle wrapper and dependencies ---
    - name: Cache Gradle
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          android/.gradle
        key: gradle-${{ runner.os }}-${{ hashFiles('android/**/*.gradle*', 'android/**/gradle-wrapper.properties') }}
        restore-keys: |
          gradle-${{ runner.os }}-

    - name: Make gradlew executable
      run: chmod +x android/gradlew

    - name: Build Android APK
      working-directory: android
      run: ./gradlew assembleDebug --no-daemon --stacktrace

    - name: Upload APK artifact
      uses: actions/upload-artifact@v4
      with:
        name: SF64RCA-debug-apk
        path: android/app/build/outputs/apk/debug/app-debug.apk
        if-no-files-found: error